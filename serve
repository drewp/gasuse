"""
todo:

sort station dpm by total dpm; hide stations with too little data

svg graphs of stuff

map of station positions and avg prices

histogram of dollars per mile (by number of miles at that price)
"""

from __future__ import division
import math
from sets import Set
from twisted.application import internet, service
from nevow import appserver
from nevow import inevow, loaders, rend, static, url, tags as T
from formless import annotate, webform
from zope.interface import implements
from rdflib.sparql.sparqlGraph import SPARQLGraph as Graph
from rdflib import URIRef, Literal, BNode, Namespace, FileInputSource
from rdflib import RDF, RDFS
from rdflib.sparql.sparqlOperators import getLiteralValue
from linegraph import LineGraph
import mpg
from gasuse import DC, DATE, GAS, DOLLAR, MILE, GALLON

dlit = lambda d: Literal(d,
                         datatype='http://www.w3.org/2001/XMLSchema#date')

class Page(rend.Page):
    docFactory = loaders.xmlfile("basic.html")
    content = "" # xml file to appear in center frame
    def render_content(self, context, data):
        return loaders.xmlfile(self.content)

class INewItem(annotate.TypedInterface):
    def newItem(self, date=annotate.String(default="today"),
                station=annotate.String(), addr=annotate.String(),
                priceGal=annotate.String(), gallons=annotate.String(),
                fee=annotate.String(), miles=annotate.String(),
                odo=annotate.String(), notes=annotate.String()):
        pass
    newItem = annotate.autocallable(newItem)

class SubmitFillUpPage(rend.Page):
    # not a Page since this one is for mobile phones. but it should
    # detect if you're a phone and draw itself accordingly (all the
    # pages should do this)
    implements(INewItem)
    docFactory = loaders.stan(T.html[T.body[webform.renderForms()]])

    def newItem(self, **kw):
        print kw
        return MainPage()

def htmlColor(r,g,b):
    clamp = lambda v: max(0, min(255, v))
    return "#%02X%02X%02X" % (clamp(r), clamp(g), clamp(b))

class FillupsPage(Page):
    content = "fillUps.html"
    addSlash = True
    def child_submit(self, ctx):
        return SubmitPage()
    def render_car(self, ctx, data):
        return car
    def data_numFillUps(self, ctx, data):
        args = inevow.IRequest(ctx).args
        try:
            n = args['numFillUps'][0]
            if n == 'all':
                return 'all'
            return int(n)
        except (KeyError, TypeError, ValueError), e:
            return 10
    def data_fillUps(self, ctx, data):
        fillUps = [f for d,f in mpg.fillUps(graph, car)]
        n = self.data_numFillUps(ctx, data)
        if n == 'all':
            n = 0
        fillUps = fillUps[-n:]
        return fillUps
    def render_numFillupsSelector(self, ctx, data):
        # 'all 165'
        return [(T.a(href=url.URL.fromString("http://gasuse.bigasterisk.com/fillUps").add('numFillUps', n))[n]," ")
                for n in [10,20,50,100,'all']]
    def render_row(self, ctx, item):
        val = graph.value
        slot = ctx.fillSlots
        for p in [
            "http://purl.org/dc/elements/1.1/date",
            "http://bigasterisk.com/2005/11/gasuse/gallons" ,
            "http://bigasterisk.com/2005/11/gasuse/gasPrice" ,
            "http://bigasterisk.com/2005/11/gasuse/tripMeter" ,
            "http://bigasterisk.com/2005/11/gasuse/milesOnThisTank" ,
            "http://bigasterisk.com/2005/11/gasuse/notes" ,
            "http://bigasterisk.com/2005/11/gasuse/odometer" ,
            "mpgColor", "pricePerGallon", "gasStationLabel",
            "dpmColor", "dollarsPerMile", "mpgTrunc"]:
            slot(p, "")
 
        for p,o in graph.predicate_objects(item):
            slot(p, str(o))

        try:
            slot("mpgTrunc", "%.2f" % float(val(item, GAS["mpgOnThisTank"])))
        except (TypeError, ValueError):
            pass

        if val(item, GAS["mpgOnThisTank"]) is not None:
            m = float(val(item, GAS["mpgOnThisTank"]))
            bright = (m - 15) / (35 - 15) * 255
            slot("mpgColor", htmlColor(50, bright, 50))

        try:
            slot("pricePerGallon",
                 "%.03f" %
                 float(val(val(item, GAS["gasPrice"]), GAS["pricePerGallon"])))
        except (TypeError, ValueError):
            pass

        try:
            slot("gasStationLabel",
                 val(val(item, GAS["gasStation"]), RDFS.label))
        except (TypeError, ValueError):
            pass

        try:
            dpm = float(val(item, GAS['dollarsPerMile']))
            slot("dollarsPerMile", "%.04f" % dpm)
            bright = (dpm - .03) / (.10 - .03) * 255
            slot("dpmColor", htmlColor(bright, 150, 150))
        except (TypeError, ValueError), e:
            pass
            
        return ctx.tag

    def fillUpsByShortName(self, shortName):
        if not hasattr(self, "_fbsn"):
            self._fbsn = {}
        if shortName not in self._fbsn:
            val = graph.value
            fillUps = []
            stns = Set()
            for stn in graph.subjects(RDFS.Class, GAS['station']):
                if val(stn, GAS['shortName']) == shortName:
                    stns.add(stn)

            for f in graph.subjects(RDFS.Class, GAS['fillUp']):
                if val(f, GAS['gasStation']) in stns:
                    fillUps.append(f)
            self._fbsn[shortName] = fillUps
            
        return self._fbsn[shortName]
        
    def dpmInDateRange(self, shortName, start, end):
        milesFromStn = 0
        dollarsFromStn = 0
        totalGal = 0
        val = graph.value
        for f in self.fillUpsByShortName(shortName):
            try:
                if not (getLiteralValue(start) <=
                        getLiteralValue(val(f, DC['date'])) <=
                        getLiteralValue(end)):
                    continue

                m = val(f, GAS['milesOnThisTank'])
                milesFromStn += float(m)
                g = val(f, GAS['gallons'])
                d = val(val(f, GAS['gasPrice']), GAS['pricePerGallon'])
                dollarsFromStn += float(g) * float(d)
                totalGal += float(g)
            except (TypeError, ValueError):
                pass
        try:
            dpm = dollarsFromStn / milesFromStn
        except ZeroDivisionError:
            dpm = 0
        return dpm, totalGal

    def data_years(self, ctx, data):
        return range(2001, 2005+1) + ['All']

    def data_stationDpmByYear(self, ctx, data):
        """
        [[u'http://bigasterisk.com/2005/11/gasuse/station/76',
        (0.066221231927710858, 25.367000000000001),
        (0.052104591261451727, 42.505000000000003),
        (0.065318293788819884, 55.646999999999998),
        (0.054380097008159559, 28.173000000000002),
        (0.080358870535714305, 13.746), (0.060841301868802447,
        165.43799999999999)],
        [u'http://bigasterisk.com/2005/11/gasuse/station/761',
        (0.066221231927710858, 25.367000000000001),
        (0.052104591261451727, 42.505000000000003),
        (0.065318293788819884, 55.646999999999998),
        (0.054380097008159559, 28.173000000000002),
        (0.080358870535714305, 13.746), (0.060841301868802447,
        165.43799999999999)], ...]       
        """
        ret = []

        shortNames = Set()
        for stn in graph.subjects(RDFS.Class, GAS['station']):
            shortName = graph.value(stn, GAS['shortName'])
            shortNames.add(shortName)
        
        for shortName in sorted(shortNames):
            row = [shortName]
            for year in self.data_years(ctx, data):
                if year == 'All':
                    s,e = dlit("1970-01-01"), dlit("2038-01-01")
                else:
                    s,e = dlit("%s-01-01" % year), dlit("%s-12-31" % year)
                dpm, totalGal = self.dpmInDateRange(shortName, s, e)
                row.append((dpm, totalGal))
            allYearTotalGal = row[-1][1]
            if allYearTotalGal > self.data_minGallonsForStationDpm(ctx, data):
                ret.append(row)
        return ret

    def data_minGallonsForStationDpm(self, ctx, data):
        return 20
        
    def render_stationDpmCell(self, ctx, data):
        dpm, totalGal = data
        bright = (dpm - .05) / (.085 - .05) * 255
        if dpm != 0:
            ctx.fillSlots("dpm", "%.03f (%.1f gal)" % (dpm, totalGal))
            ctx.fillSlots("dpmColor", htmlColor(bright, 150, 150))
        else:
            ctx.fillSlots("dpm", "")
            ctx.fillSlots("dpmColor", "#333333")
        return ctx.tag

class LineGraphPage(Page):
    addSlash = True
    def __init__(self, fillUpFunc, label):
        self.fillUpFunc, self.label = fillUpFunc, label
        
    def render_content(self, context, data):
        return loaders.stan(T.html[T.body[
        T.p[self.label, " by fillup date"],
        T.Tag("embed")(src="graph", type="image/svg+xml",
                       width=850, height=260)
        ]])
    
    def child_graph(self, ctx):
        vals = []
        for i, (date, f) in enumerate(mpg.fillUps(graph, car)):
            try:
                # clean up the data- i should be able to screen for datatype
                if not date.startswith("200") or len(date) != 10:
                    continue
                
                v = self.fillUpFunc(f)
                if v is not None:
                    vals.append((date, float(v)))
            except ValueError:
                pass
        return LineGraph(vals)
    
    def locateChild(self, ctx, segments):
        print "locate", segments
        if segments[-1] == 'graph':
            return LineGraphPage(*self.funcDesc(segments[0])).child_graph(ctx), []
        if segments[0] == '':
            return LineGraphPage(self.fillUpFunc, self.label), []
        return LineGraphPage(*self.funcDesc(segments[0])), []
    
    def funcDesc(self, word):
        if word == 'dollarsPerMile':
            return (lambda fillUp: graph.value(fillUp, GAS['dollarsPerMile']),
                    'dollarsPerMile')
        return (lambda fillUp: graph.value(graph.value(fillUp,
                                                      GAS['gasPrice']),
                                          GAS['pricePerGallon']),
                "pricePerGallon")

class MainPage(Page):
    content = "main.html"
    def child_fillUps(self, ctx):
        return FillupsPage()
    def child_lineGraph(self, ctx):
        return LineGraphPage(lambda fillUp: graph.value(graph.value(fillUp,
                                                            GAS['gasPrice']),
                                                        GAS['pricePerGallon']),
                             "pricePerGallon")
    def child_submitFillUp(self, ctx):
        return SubmitFillUpPage()

graph = Graph()
graph.parse(FileInputSource(open("gas.rdf")))

car = GAS['car/drewHonda']

mpg.calcMpg(graph, car)

application = service.Application('gasuse')
webServer = internet.TCPServer(8081, appserver.NevowSite(MainPage()))
webServer.setServiceParent(application)
