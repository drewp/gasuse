"""
todo:

sort station dpm by total dpm; hide stations with too little data

svg graphs of stuff

map of station positions and avg prices

histogram of dollars per mile (by number of miles at that price)
"""

from __future__ import division
import math, time
from sets import Set
from xml.utils import iso8601
from twisted.application import internet, service
import formal
from nevow import appserver
from nevow import inevow, loaders, rend, static, url, tags as T, guard
from nevow.vhost import VHostMonsterResource
from formless import annotate, webform
from zope.interface import implements
from rdflib.sparql.sparqlGraph import SPARQLGraph
from rdflib import URIRef, Literal, BNode, Namespace, FileInputSource
from rdflib.Graph import Graph, ConjunctiveGraph
from rdflib import RDF, RDFS
from rdflib.sparql.sparqlOperators import getLiteralValue
from linegraph import LineGraph
import mpg
from gasuse import DC, DATE, GAS, DOLLAR, MILE, GALLON
XS = Namespace("http://www.w3.org/2001/XMLSchema#")

dlit = lambda d: Literal(d,
                         datatype='http://www.w3.org/2001/XMLSchema#date')

class Page(rend.Page):
    docFactory = loaders.xmlfile("basic.html")
    content = "" # xml file to appear in center frame
    def render_content(self, context, data):
        return loaders.xmlfile(self.content)

def stationUri(existingGraph, newGraph, station, addr):
    """
    station like "chevon"
    addr like "foothill SL"
    """
    s = GAS['station/hash%s' % hash(station + addr)]
    typeStmt = (s, RDF.type, GAS['Station'])
    if typeStmt not in existingGraph:
        newGraph.add(typeStmt)
        if addr:
            newGraph.add((s, GAS['shortAddress'], Literal(addr)))
        if station:
            newGraph.add((s, GAS['shortName'], Literal(station)))
        if addr or station:
            newGraph.add((s, RDFS.label,
                          Literal("%s near %s" % (station, addr))))
    return s

class SubmitFillUpPage(formal.ResourceMixin, rend.Page):
    # not a Page since this one is for mobile phones. but it should
    # detect if you're a phone and draw itself accordingly (all the
    # pages should do this)

    docFactory = loaders.stan(
        T.html[
          T.head[
            T.link(rel='stylesheet', type='text/css', href=url.root.child('formal.css')),
            T.script(type='text/javascript', src='js/formal.js'),
            T.style["""
        div.1-fee-field { background: #ff0000; border: 11px }
            """]
            ],
          T.body[T.div[
            T.div(render=T.directive("loggedIn")),
            T.directive('form 1')
            ]
            ]
          ])
    def render_loggedIn(self, ctx, data):
        if hasattr(inevow.ISession(ctx), 'password'):
            return "[logged in]"
        else:
            return ""
        
    def form_1(self, ctx):
        form = formal.Form()
        if not hasattr(inevow.ISession(ctx), 'password'):
            form.addField('password', formal.String())
        form.addField('date', formal.String())
        form.data['date'] = 'today'
        form.addField('station', formal.String(missing=""))# description="e.g. shell"),
        form.addField('addr', formal.String(missing=""))# label="address",
#                             description="e.g. oak and main SF"),
        form.addField('priceGal', formal.String(missing=""))
        form.addField('gallons', formal.String(missing=""))
        form.addField('fee', formal.String(missing=""))
        form.addField('odo', formal.String(missing=""))
        form.addField('notes', formal.String(missing=""))
        form.addAction(self.newItem)
        return form

    def newItem(self, ctx, form, data):
        password, date, station, addr, priceGal, gallons, fee, odo, notes = [
          data.get(x) for x in
          "password date station addr priceGal gallons fee odo notes".split()]

        sess = inevow.ISession(ctx)
        if hasattr(sess, 'password'):
            print "already had password", sess.password
        else:
            correctPassword = (Graph()
                               .parse("password.nt", format="nt")
                               .value(GAS['site'], GAS['password']))
            if password == correctPassword:
                print "logged in"
                sess.password = True
            else:
                return static.staticHTML("incorrect password, not submitting")

        g = graph.get_context(GAS['webAdded#context'])
        print "webAdded had", len(g)

        car = GAS['car/drewCivicHybrid']

        if date == 'today':
            date = time.strftime("%Y-%m-%d")
        date = Literal(date, datatype=XS['date'])

        station = stationUri(graph, g, station, addr)

        price = BNode()
        g.add((price, GAS['gasStation'], station))
        g.add((price, GAS['pricePerGallon'],
               Literal(priceGal, datatype=GAS['type#dollar'])))
        g.add((price, DC['date'], date))

        fill = BNode()
        g.add((fill, RDF.type, GAS['FillUp']))
        g.add((fill, DC['created'],
               Literal(iso8601.tostring(time.time(), timezone=time.altzone))))
        g.add((fill, DC['date'], date))
        for s, o in dict(car=car,
                         gallons=Literal(gallons, datatype=GAS['type#gallon']),
                         gasPrice=price,
                         gasStation=station,
                         odometer=Literal(odo, datatype=GAS['type#mile']),
                         notes=Literal(notes),
                         ).items():
            if o:
                g.add((fill, GAS[s], o))        

        g.serialize("web_added.nt", format="nt")
        return static.staticHTML("saved; webAdded now has %s nodes" % len(g))

def htmlColor(r,g,b):
    clamp = lambda v: max(0, min(255, v))
    return "#%02X%02X%02X" % (clamp(r), clamp(g), clamp(b))

class FillupsPage(Page):
    content = "fillUps.html"
    addSlash = True
    def render_car(self, ctx, data):
        args = inevow.IRequest(ctx).args
        if 'car' in args:
            return GAS['car/%s' % args['car'][0]]
        return GAS['car/drewCivicHybrid']
    def data_numFillUps(self, ctx, data):
        args = inevow.IRequest(ctx).args
        try:
            n = args['numFillUps'][0]
            if n == 'all':
                return 'all'
            return int(n)
        except (KeyError, TypeError, ValueError), e:
            return 10
    def data_fillUps(self, ctx, data):
        fillUps = [f for d,f in mpg.fillUps(graph, self.render_car(ctx, data))]
        n = self.data_numFillUps(ctx, data)
        if n == 'all':
            n = 0
        fillUps = fillUps[-n:]
        return fillUps
    def render_numFillupsSelector(self, ctx, data):
        # 'all 165'
        return [(T.a(href=url.here.add('numFillUps', n))[n]," ")
                for n in [10,20,50,100,'all']]
    def render_row(self, ctx, item):
        val = lambda *args: str(graph.value(*args))
        slot = ctx.fillSlots
        for p in [
            "http://purl.org/dc/elements/1.1/date",
            "http://bigasterisk.com/2005/11/gasuse/gallons" ,
            "http://bigasterisk.com/2005/11/gasuse/gasPrice" ,
            "http://bigasterisk.com/2005/11/gasuse/tripMeter" ,
            "http://bigasterisk.com/2005/11/gasuse/milesOnThisTank" ,
            "http://bigasterisk.com/2005/11/gasuse/notes" ,
            "http://bigasterisk.com/2005/11/gasuse/odometer" ,
            "mpgColor", "pricePerGallon", "gasStationLabel",
            "dpmColor", "dollarsPerMile", "mpgTrunc"]:
            slot(p, "")
 
        for p,o in graph.predicate_objects(item):
            slot(str(p), str(o))

        try:
            slot("mpgTrunc", "%.2f" % float(val(item, GAS["mpgOnThisTank"])))
        except (TypeError, ValueError), e:
            print e
            pass

        if val(item, GAS["mpgOnThisTank"]) != "None": # val has str()
            m = float(val(item, GAS["mpgOnThisTank"]))
            bright = (m - 15) / (55 - 15) * 255
            slot("mpgColor", htmlColor(50, bright, 50))

        try:
            slot("pricePerGallon",
                 "%.03f" %
                 float(val(val(item, GAS["gasPrice"]), GAS["pricePerGallon"])))
        except (TypeError, ValueError), e:
            print e
            pass

        try:
            stns = graph.objects(item, GAS["gasStation"])
            labels = [graph.label(s) for s in stns]
            slot("gasStationLabel", labels)
        except (TypeError, ValueError), e:
            print e
            pass

        try:
            dpm = float(val(item, GAS['dollarsPerMile']))
            slot("dollarsPerMile", "%.04f" % dpm)
            bright = (dpm - .03) / (.10 - .03) * 255
            slot("dpmColor", htmlColor(bright, 150, 150))
        except (TypeError, ValueError), e:
            print e
            pass
            
        return ctx.tag

    def fillUpsByShortName(self, car, shortName):
        if not hasattr(self, "_fbsn"):
            self._fbsn = {}
        if shortName not in self._fbsn:
            val = graph.value
            fillUps = []
            stns = Set()
            for stn in graph.subjects(RDF.type, GAS['Station']):
                if val(stn, GAS['shortName'], any=True) == shortName:
                    stns.add(stn)

            for f in graph.subjects(RDF.type, GAS['FillUp']):
                if (val(f, GAS['car']) == car and
                    val(f, GAS['gasStation']) in stns):
                    fillUps.append(f)
            self._fbsn[shortName] = fillUps
            
        return self._fbsn[shortName]
        
    def dpmInDateRange(self, car, shortName, start, end):
        milesFromStn = 0
        dollarsFromStn = 0
        totalGal = 0
        val = graph.value
        for f in self.fillUpsByShortName(car, shortName):
            try:
                if not (getLiteralValue(start) <=
                        getLiteralValue(val(f, DC['date'])) <=
                        getLiteralValue(end)):
                    continue

                m = val(f, GAS['milesOnThisTank'])
                milesFromStn += float(m)
                g = val(f, GAS['gallons'])
                d = val(val(f, GAS['gasPrice']), GAS['pricePerGallon'])
                dollarsFromStn += float(g) * float(d)
                totalGal += float(g)
            except (TypeError, ValueError):
                pass
        try:
            dpm = dollarsFromStn / milesFromStn
        except ZeroDivisionError:
            dpm = 0
        return dpm, totalGal

    def data_years(self, ctx, data):
        return range(2001, 2007+1) + ['All']

    def data_stationDpmByYear(self, ctx, data):
        """
        [[u'http://bigasterisk.com/2005/11/gasuse/station/76',
        (0.066221231927710858, 25.367000000000001),
        (0.052104591261451727, 42.505000000000003),
        (0.065318293788819884, 55.646999999999998),
        (0.054380097008159559, 28.173000000000002),
        (0.080358870535714305, 13.746), (0.060841301868802447,
        165.43799999999999)],
        [u'http://bigasterisk.com/2005/11/gasuse/station/761',
        (0.066221231927710858, 25.367000000000001),
        (0.052104591261451727, 42.505000000000003),
        (0.065318293788819884, 55.646999999999998),
        (0.054380097008159559, 28.173000000000002),
        (0.080358870535714305, 13.746), (0.060841301868802447,
        165.43799999999999)], ...]       
        """
        ret = []

        shortNames = Set()
        for stn in graph.subjects(RDF.type, GAS['Station']):
            shortName = graph.value(stn, GAS['shortName'], any=True)
            shortNames.add(shortName)

        car = self.render_car(ctx, data)
        for shortName in sorted(shortNames):
            row = [shortName]
            for year in self.data_years(ctx, data):
                if year == 'All':
                    s,e = dlit("1970-01-01"), dlit("2038-01-01")
                else:
                    s,e = dlit("%s-01-01" % year), dlit("%s-12-31" % year)
                dpm, totalGal = self.dpmInDateRange(car, shortName, s, e)
                row.append((dpm, totalGal))
            allYearTotalGal = row[-1][1]
            if allYearTotalGal > self.data_minGallonsForStationDpm(ctx, data):
                ret.append(row)
        return ret

    def data_minGallonsForStationDpm(self, ctx, data):
        return 20
        
    def render_stationDpmCell(self, ctx, data):
        dpm, totalGal = data
        bright = (dpm - .05) / (.085 - .05) * 255
        if dpm != 0:
            ctx.fillSlots("dpm", "%.03f (%.1f gal)" % (dpm, totalGal))
            ctx.fillSlots("dpmColor", htmlColor(bright, 150, 150))
        else:
            ctx.fillSlots("dpm", "")
            ctx.fillSlots("dpmColor", "#333333")
        return ctx.tag

class LineGraphPage(Page):
    addSlash = True
    def __init__(self, fillUpFunc, label):
        self.fillUpFunc, self.label = fillUpFunc, label
        
    def render_content(self, context, data):
        return loaders.stan(T.html[T.body[
        T.p[self.label, " by fillup date"],
        T.Tag("embed")(src="graph", type="image/svg+xml",
                       width=850, height=260)
        ]])
    
    def child_graph(self, ctx):
        vals = []
        for i, (date, f) in enumerate(mpg.fillUps(graph, car)):
            try:
                # clean up the data- i should be able to screen for datatype
                if not date.startswith("200") or len(date) != 10:
                    continue
                
                v = self.fillUpFunc(f)
                if v is not None:
                    vals.append((date, float(v)))
            except ValueError:
                pass
        return LineGraph(vals)
    
    def locateChild(self, ctx, segments):
        print "locate", segments
        if segments[-1] == 'graph':
            return LineGraphPage(*self.funcDesc(segments[0])).child_graph(ctx), []
        if segments[0] == '':
            return LineGraphPage(self.fillUpFunc, self.label), []
        return LineGraphPage(*self.funcDesc(segments[0])), []
    
    def funcDesc(self, word):
        if word == 'dollarsPerMile':
            return (lambda fillUp: graph.value(fillUp, GAS['dollarsPerMile']),
                    'dollarsPerMile')
        return (lambda fillUp: graph.value(graph.value(fillUp,
                                                      GAS['gasPrice']),
                                          GAS['pricePerGallon']),
                "pricePerGallon")

class MainPage(Page):
    content = "main.html"
    def child_fillUps(self, ctx):
        return FillupsPage()
    def child_lineGraph(self, ctx):
        return LineGraphPage(lambda fillUp: graph.value(graph.value(fillUp,
                                                            GAS['gasPrice']),
                                                        GAS['pricePerGallon']),
                             "pricePerGallon")
    def child_submitFillUp(self, ctx):
        return SubmitFillUpPage()
setattr(MainPage, 'child_formal.css', formal.defaultCSS)
setattr(MainPage, 'child_js', formal.formsJS)
setattr(MainPage, 'child_doap.rdf', static.File("doap.rdf"))
    
graph = SPARQLGraph(ConjunctiveGraph())

def setupGetContextMethod(graph):
    # why can't i have get_context from old BackwardCompatGraph? unclear
    # how that should be done in ConjunctiveGraph
    def get_context(self, identifier, quoted=False):
        """Return a context graph for the given identifier

        identifier must be a URIRef or BNode.
        """
        assert isinstance(identifier, URIRef) or \
               isinstance(identifier, BNode), type(identifier)
        if quoted:
            assert False
            return QuotedGraph(self.store, identifier)
            #return QuotedGraph(self.store, Graph(store=self.store,
            #                                     identifier=identifier))
        else:
            return Graph(store=self.store, identifier=identifier,
                         namespace_manager=self)
            #return Graph(self.store, Graph(store=self.store,
            #                               identifier=identifier))


    import types
    graph.get_context = types.MethodType(get_context, graph, graph.__class__)
setupGetContextMethod(graph)


for inp, fmt in [('complete1.rdf', 'xml'),
                 ('googlebak.n3', 'n3')]:
    graph.parse(FileInputSource(open(inp)),
                publicID=GAS['%s#context' % inp.split('.')[0]],
                format=fmt)
    print "%s triples after %s" % (len(graph), inp)

graph.parse("web_added.nt", publicID=GAS['webAdded#context'], format="nt")
for car in [GAS['car/drewCivicHybrid'],
            #GAS['car/drewHonda'],
            ]:
    mpg.calcMpg(graph, car)

application = service.Application('gasuse')
main = MainPage()
from nevow.vhost import VHostMonsterResource
main.putChild('vhost', VHostMonsterResource())

webServer = internet.TCPServer(8081, appserver.NevowSite((main)))
webServer.setServiceParent(application)
